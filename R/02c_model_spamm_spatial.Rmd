---
title: "spaMM Model for Mixed + Spatial effects (Matern)"
output:
  html_document:
    df_print: paged
---

## Setup

```{r}
# --- Setup
if (!require(spaMM)) {
  install.packages("spaMM", repos = "https://pbil.univ-lyon1.fr/CRAN/")
  library(spaMM)
}
if (!require(dplyr)) {
  install.packages("dplyr")
  library(dplyr)
}
# Input/output folder paths
RAW_DATA_DIR <- "../data/raw/"
INTERIM_DATA_DIR <- "../data/interim/"
PROCESSED_DATA_DIR <- "../data/processed/"
```


```{r}
data <- read.csv(file.path(PROCESSED_DATA_DIR, 'final_data_for_modeling.csv'))
print(dim(data))
print(head(data, 3))
```


```{r}
data$cpb_abundance <- (data$cpba_count + data$cpbl_count) / 2
data$croptype <- ifelse(data$croptype == 43, 1, 0)

# --- Scale numeric predictors
numeric_vars <- c(
  "gdd", "cum_gdd", "wei_intensity", "wei_prop",
  "summer_avg_temp", "summer_avg_percip", "summer_heavy_rainfall_days",
  "summer_hottest_temp", "winter_coldest_temp",
  "winter_extreme_cold_days","winter_warm_day_count"
)

# Scale each numeric variable if it exists in data
for (v in numeric_vars) {
  if (v %in% names(data)) data[[v]] <- scale(data[[v]])
}


# Convert 'farm' and 'year' to factors for use as random effects
data$farm <- as.factor(data$farm)
data$year <- as.factor(data$year)
```



## Model spamm_RF: Fixed + Random (year + farm)

```{r}
spamm_RF <- fitme(
  cpb_abundance ~
    gdd + cum_gdd + croptype + wei_intensity + wei_prop + summer_avg_temp + 
    summer_avg_percip + summer_heavy_rainfall_days + summer_hottest_temp + 
    winter_coldest_temp + winter_extreme_cold_days + winter_warm_day_count +
    (1 | year) + (1 | farm),
  data = data, family = gaussian()
)

# 2a. Metrics for spamm_RF
AIC_RF         <- AIC(spamm_RF)
res_RF         <- residuals(spamm_RF)
MSE_RF         <- mean(res_RF^2)
var_fixed_RF   <- var(predict(spamm_RF))
var_year_RF    <- unname(spamm_RF$lambda["year"])
var_farm_RF    <- unname(spamm_RF$lambda["farm"])
var_resid_RF   <- unname(spamm_RF$phi)
R2m_RF         <- var_fixed_RF / (var_fixed_RF + var_year_RF + var_farm_RF + var_resid_RF)
R2c_RF         <- (var_fixed_RF + var_year_RF + var_farm_RF) /
  (var_fixed_RF + var_year_RF + var_farm_RF + var_resid_RF)

cat("\n--- Model spamm_RF (Fixed + Random) ---\n")
cat("AIC:           ", round(AIC_RF, 2), "\n")
cat("MSE:           ", round(MSE_RF, 3), "\n")
cat("R² (marginal): ", round(R2m_RF, 3), "\n")
cat("R² (conditional): ", round(R2c_RF, 3), "\n")

```



## Model spamm_SRF: Fixed + Random + Spatial

```{r}
spamm_SRF <- fitme(
  cpb_abundance ~
    gdd + cum_gdd + wei_intensity + wei_prop + summer_avg_temp + 
    summer_avg_percip + summer_heavy_rainfall_days + summer_hottest_temp + 
    winter_coldest_temp + winter_extreme_cold_days + winter_warm_day_count +
    Matern(1 | lat + lng) + (1 | year) + (1 | farm),
  data = data, family = gaussian()
)

# 3a. Metrics for spamm_SRF
AIC_SRF          <- AIC(spamm_SRF)
res_SRF          <- residuals(spamm_SRF)
MSE_SRF          <- mean(res_SRF^2)
var_fixed_SRF    <- var(predict(spamm_SRF))
var_spatial_SRF  <- unname(spamm_SRF$lambda["lat + lng"])
var_year_SRF     <- unname(spamm_SRF$lambda["year"])
var_farm_SRF     <- unname(spamm_SRF$lambda["farm"])
var_resid_SRF    <- unname(spamm_SRF$phi)
R2m_SRF          <- var_fixed_SRF / (var_fixed_SRF + var_spatial_SRF + var_year_SRF + var_farm_SRF + var_resid_SRF)
R2c_SRF          <- (var_fixed_SRF + var_spatial_SRF + var_year_SRF + var_farm_SRF) /
  (var_fixed_SRF + var_spatial_SRF + var_year_SRF + var_farm_SRF + var_resid_SRF)

cat("\n--- Model spamm_SRF (Fixed + Random + Spatial) ---\n")
cat("AIC:           ", round(AIC_SRF, 2), "\n")
cat("MSE:           ", round(MSE_SRF, 3), "\n")
cat("R² (marginal): ", round(R2m_SRF, 3), "\n")
cat("R² (conditional): ", round(R2c_SRF, 3), "\n")

```



## Summaries

```{r}
saveRDS(spamm_SRF, file = "../models/spamm_SRF_full.rds")

summary(spamm_RF)
summary(spamm_SRF)
```


## Extract the “conditional AIC” (2nd element) from each AIC vector

```{r}
condAIC_RF  <- AIC_RF[2]
condAIC_SRF <- AIC_SRF[2]

# Print them
cat(
  "Conditional AIC (spamm_RF):  ", round(condAIC_RF, 2), "\n",
  "Conditional AIC (spamm_SRF): ", round(condAIC_SRF, 2), "\n"
)
```


```{r}
# extract the fixed‐effects table
tab   <- summary(spamm_SRF)$beta_table
est2  <- tab[, "Estimate"]
se2   <- tab[, "Cond. SE"]

# use normal quantile ~1.96 for large‐sample ML estimates
z     <- qnorm(0.975)

CI_spamm <- data.frame(
  Estimate = est2,
  Lower95  = est2 - z * se2,
  Upper95  = est2 + z * se2
)
CI_spamm
```

## Figure 1. Sampling locations map


```{r}

# --- Statewide map (full Wisconsin extent)
# (adds county outlines for context)
wi_counties <- map_data("county") %>% dplyr::filter(region == "wisconsin")

fig1a_state <- ggplot() +
  geom_polygon(data = wi_poly, aes(long, lat, group = group),
               fill = "grey95", color = "grey70", linewidth = 0.3) +
  geom_polygon(data = wi_counties, aes(long, lat, group = group),
               fill = NA, color = "grey85", linewidth = 0.2) +
  geom_point(data = data, aes(x = lng, y = lat),
             alpha = 0.6, size = 0.9) +
  coord_quickmap() +
  labs(x = "Longitude", y = "Latitude",
       title = "Sampling locations across Wisconsin (statewide)") +
  theme_bw() +
  theme(panel.grid = element_blank())
print(fig1a_state)
ggsave("../fig/Fig1a_sampling_statewide.png", fig1a_state, width = 6.5, height = 5, dpi = 300)

# --- Zoomed map (your original extent-based crop)
fig1b_zoom <- fig1_sampling +
  ggtitle("Sampling locations (zoom on sampled extent)")
print(fig1b_zoom)
ggsave("../fig/Fig1b_sampling_zoom.png", fig1b_zoom, width = 6.5, height = 5, dpi = 300)

# --- (Optional) side-by-side export
if (!requireNamespace("cowplot", quietly = TRUE)) install.packages("cowplot")
library(cowplot)
fig1_side_by_side <- cowplot::plot_grid(fig1a_state, fig1b_zoom, nrow = 1, labels = c("A", "B"))
ggsave("../fig/Fig1_sampling_statewide_and_zoom.png", fig1_side_by_side, width = 12, height = 5, dpi = 300)

```



## Figure 2. Spatial random field from spaMM (Matern effect only)

```{r}
# ─────────────────────────────────────────────────────────────────────────────
# Build coords_df (points with spatial BLUPs) and grid_df (interpolated surface)
# ─────────────────────────────────────────────────────────────────────────────
if (!requireNamespace("akima", quietly = TRUE)) install.packages("akima")
if (!requireNamespace("viridis", quietly = TRUE)) install.packages("viridis")
if (!requireNamespace("scales", quietly = TRUE)) install.packages("scales")
library(akima); library(ggplot2); library(viridis); library(scales)

# 1) Extract the Matern random effects (BLUPs)
rL <- ranef(spamm_SRF)
mat_name <- grep("Matern", names(rL), value = TRUE)        # e.g., "Matern(1 | lat + lng)"
stopifnot(length(mat_name) == 1)
mat_re <- as.numeric(rL[[mat_name]])                       # vector of BLUPs

# 2) Reconstruct the unique coordinate table in the same order spaMM used
uniq_coords <- unique(data[c("lat","lng")])                # first occurrence order
if (nrow(uniq_coords) != length(mat_re)) {
  stop("Length mismatch between unique coords and Matern BLUPs. 
       Check for any preprocessing that changed 'data' after fitting.")
}
uniq_coords$sp_re <- mat_re

# 3) Map each observation to its spatial BLUP
key_obs  <- paste(data$lat, data$lng)
key_uniq <- paste(uniq_coords$lat, uniq_coords$lng)
coords_df <- data.frame(
  lng   = data$lng,
  lat   = data$lat,
  sp_re = uniq_coords$sp_re[ match(key_obs, key_uniq) ]
)

# 4) Interpolate to a regular grid (no extrapolation outside convex hull)
interp_grid <- akima::interp(
  x         = coords_df$lng,
  y         = coords_df$lat,
  z         = coords_df$sp_re,
  duplicate = "mean",
  nx        = 300, ny = 300,
  extrap    = FALSE
)
grid_df <- expand.grid(lng = interp_grid$x, lat = interp_grid$y)
grid_df$sp_re <- as.vector(interp_grid$z)
grid_df <- grid_df[!is.na(grid_df$sp_re), ]

# ─────────────────────────────────────────────────────────────────────────────
# Figure 2b. Zoomed spatial random field (no WI outline), lon/lat axes
# ─────────────────────────────────────────────────────────────────────────────
pad_x <- 0.05
pad_y <- 0.05
x_rng <- range(coords_df$lng, na.rm = TRUE) + c(-pad_x, pad_x)
y_rng <- range(coords_df$lat, na.rm = TRUE) + c(-pad_y, pad_y)

grid_zoom <- subset(
  grid_df,
  lng >= x_rng[1] & lng <= x_rng[2] &
  lat >= y_rng[1] & lat <= y_rng[2]
)

fig2_spatial_zoom <- ggplot(grid_zoom, aes(lng, lat, fill = sp_re)) +
  geom_raster(interpolate = TRUE) +
  geom_contour(aes(z = sp_re), colour = "white", alpha = 0.35, linewidth = 0.25, bins = 8) +
  # (optional) show sampling points for context:
  # geom_point(data = coords_df, aes(lng, lat), inherit.aes = FALSE,
  #            size = 0.25, alpha = 0.25, colour = "black") +
  coord_equal(xlim = x_rng, ylim = y_rng, expand = FALSE) +
  scale_fill_viridis_c(name = "Spatial effect", option = "magma") +
  scale_x_continuous("Longitude", breaks = scales::pretty_breaks(6)) +
  scale_y_continuous("Latitude",  breaks = scales::pretty_breaks(6)) +
  labs(title = "Spatial random field (Matérn)") +
  theme_classic(base_size = 11) +
  theme(
    panel.border   = element_rect(colour = "grey50", fill = NA, linewidth = 0.4),
    plot.title     = element_text(face = "bold"),
    legend.position = "right"
  )

print(fig2_spatial_zoom)
# Save (uncomment when ready)
ggsave("../fig/Fig2b_spatial_random_field_zoom.png",
        fig2_spatial_zoom, width = 6.5, height = 5.2, dpi = 300)
```
## Figure 3: Partial effect plots for significant predictors (fixed effects only)

```{r}
# ─────────────────────────────────────────────────────────────────────────────
# Figure 3 (fixed): Partial effect plots for significant predictors (fixed only)
# ─────────────────────────────────────────────────────────────────────────────
library(dplyr)
library(ggplot2)
library(purrr)
library(tidyr)

# Build a newdata grid varying ONE scaled variable; others fixed at 0 (their mean)
make_effect_df <- function(var_name, n = 120) {
  base <- list(
    lat = mean(data$lat),
    lng = mean(data$lng),
    year = factor(levels(data$year)[1], levels = levels(data$year)),
    farm = factor(levels(data$farm)[1], levels = levels(data$farm)),
    gdd = 0, cum_gdd = 0, wei_intensity = 0, wei_prop = 0,
    summer_avg_temp = 0, summer_avg_percip = 0, summer_heavy_rainfall_days = 0,
    summer_hottest_temp = 0, winter_coldest_temp = 0,
    winter_extreme_cold_days = 0, winter_warm_day_count = 0
  )
  rng <- range(as.numeric(data[[var_name]]), na.rm = TRUE)
  base[[var_name]] <- seq(rng[1], rng[2], length.out = n)
  nd <- as.data.frame(base)
  nd$x   <- nd[[var_name]]
  nd$fit <- as.numeric(predict(spamm_SRF, newdata = nd, type = "response", level = 0)) # <- numeric!
  nd$variable <- var_name
  nd[, c("x","fit","variable")]
}

vars_to_plot <- c("cum_gdd","wei_intensity","summer_heavy_rainfall_days","winter_coldest_temp")
eff_df <- bind_rows(lapply(vars_to_plot, make_effect_df))

var_labs <- c(
  cum_gdd = "Cumulative GDD (scaled)",
  wei_intensity = "Weighted potato intensity (scaled)",
  summer_heavy_rainfall_days = "Summer heavy rainfall days (scaled)",
  winter_coldest_temp = "Winter coldest temperature (scaled)"
)

fig3_partial <- ggplot(eff_df, aes(x = x, y = fit)) +
  geom_line() +
  facet_wrap(~ variable, scales = "free_x", ncol = 2, labeller = as_labeller(var_labs)) +
  labs(x = "Scaled predictor", y = "Predicted abundance (fixed effects only)",
       title = "Partial effects from spaMM (fixed effects only)") +
  theme_minimal()

print(fig3_partial)
ggsave("../fig/Fig3_partial_effects.png", fig3_partial, width = 7, height = 6, dpi = 300)
```

## Figure 4: Residual diagnostics (spaMM) – Residuals vs Fitted & QQ-plot

```{r}
# ─────────────────────────────────────────────────────────────────────────────
# Figure 4 (base R): Residuals vs Fitted & QQ-plot to PNG
# ─────────────────────────────────────────────────────────────────────────────
resid_vals  <- residuals(spamm_SRF, type = "response")
fitted_vals <- fitted(spamm_SRF)

png("../fig/Fig4_residual_diagnostics.png", width = 1600, height = 800, res = 200)
par(mfrow = c(1, 2), mar = c(4,4,2,1))

plot(fitted_vals, resid_vals,
     xlab = "Fitted values", ylab = "Residuals",
     main = "Residuals vs Fitted", pch = 16, col = rgb(0,0,0,0.3))
abline(h = 0, lty = 2)

qqnorm(resid_vals, main = "Normal Q–Q of residuals",
       pch = 16, col = rgb(0,0,0,0.3))
qqline(resid_vals, col = "red", lty = 2)

dev.off()
```



